{
  "author": {
    "name": "https://github.com/pgriess"
  },
  "name": "jspack",
  "description": "JavaScript library to pack primitives to octet arrays, packaged for NodeJS.",
  "version": "0.0.1",
  "homepage": "http://github.com/birchroad/node-jspack",
  "repository": {
    "type": "git",
    "url": "git://github.com/birchroad/node-jspack.git"
  },
  "main": "./jspack.js",
  "maintainers": [
    {
      "name": "Peter Magnusson",
      "email": "peter@birchroad.net",
      "url": "http://github.com/birchroad/node-jspack"
    }
  ],
  "readme": "Disclaimer:  The jspack module and documentation are essentially ports of the\nPython struct module and documentation, with such changes as were necessary.\nIf any Python people are miffed that I've ripped off their docs, let me know,\nand I'll gladly revise them.\n\nThis module performs conversions between JavaScript values and C structs\nrepresented as octet arrays (i.e. JavaScript arrays of integral numbers\nbetween 0 and 255, inclusive).  It uses format strings (explained below) as\ncompact descriptions of the layout of the C structs and the intended conversion\nto/from JavaScript values.  This can be used to handle binary data stored in\nfiles, or received from network connections or other sources.\n\n\nThe module defines the following functions:\n\n  Unpack(fmt, a, p)\n    Return an array containing values unpacked from the octet array a,\n  beginning at position p, according to the supplied format string.  If there\n  are more octets in a than required by the format string, the excess is\n  ignored.  If there are fewer octets than required, Unpack() will return\n  undefined.  If no value is supplied for the p argument, zero is assumed.\n\n  PackTo(fmt, a, p, values)\n    Pack and store the values array into the supplied octet array a, beginning\n  at position p.  If there are more values supplied than are specified in the\n  format string, the excess is ignored.  If there are fewer values supplied,\n  PackTo() will return false.  If there is insufficient space in a to store\n  the packed values, PackTo() will return false.  On success, PackTo() returns\n  the a argument. If any value is of an inappropriate type, the results are\n  undefined.\n\n  Pack(fmt, values)\n    Return an octet array containing the packed values array.  If there are\n  more values supplied than are specified in the format string, the excess is\n  ignored.  If there are fewer values supplied, Pack() will return false.  If\n  any value is of an inappropriate type, the results are undefined.\n\n  CalcLength(fmt)\n    Return the number of octets required to store the given format string.\n\n\nFormat characters have the following meanings; the conversion between C and\nJavaScript values should be obvious given their types:\n\n    Format | C Type         | JavaScript Type   | Size (octets) | Notes\n    -------------------------------------------------------------------\n       A   | char[]         | Array             |     Length     |  (1)\n       x   | pad byte       | N/A               |        1       |\n       c   | char           | string (length 1) |        1       |  (2)\n       b   | signed char    | number            |        1       |  (3)\n       B   | unsigned char  | number            |        1       |  (3)\n       h   | signed short   | number            |        2       |  (3)\n       H   | unsigned short | number            |        2       |  (3)\n       i   | signed long    | number            |        4       |  (3)\n       I   | unsigned long  | number            |        4       |  (3)\n       l   | signed long    | number            |        4       |  (3)\n       L   | unsigned long  | number            |        4       |  (3)\n       s   | char[]         | string            |     Length     |  (2)\n       f   | float          | number            |        4       |  (4)\n       d   | double         | number            |        8       |  (5)\n\nNotes:\n\n  (1) The \"A\" code simply returns a slice of the source octet array.  This is\n  primarily useful when a data structure contains bytes which are subject to\n  multiple intepretations (e.g. unions), and the data structure is being\n  decoded in multiple passes.\n\n  (2) The \"c\" and \"s\" codes handle strings with codepoints between 0 and 255,\n  inclusive.  The data are not bounds-checked, so strings containing  characters\n  with codepoints outside this range will encode to \"octet\" arrays that contain\n  values outside the range of an octet.  Furthermore, since these codes decode\n  octet arrays by assuming the octets represent UNICODE codepoints, they may\n  not \"correctly\" decode bytes in the range 128-255, since that range is subject\n  to multiple interpretations.  Caveat coder!\n\n  (3) The 8 \"integer\" codes clip their encoded values to the minima and maxmima\n  of their respective types:  If you invoke Struct.Pack('b', [-129]), for\n  instance, the result will be [128], which is the octet encoding of -128,\n  which is the minima of a signed char.  Similarly, Struct.Pack('h', [-32769])\n  returns [128, 0].  Fractions are truncated.\n\n  (4) Since JavaScript doesn't natively support 32-bit floats, whenever a float\n  is stored, the source JavaScript number must be rounded.  This module applies\n  correct rounding during this process.  Numbers with magnitude greater than or\n  equal to 2**128-2**103 round to either positive or negative Infinity. The\n  rounding algorithm assumes that JavsScript is using exactly 64 bits of\n  floating point precision; 128-bit floating point will result in subtle errors.\n\n  (5) This module assumes that JavaScript is using 64 bits of floating point\n  precision, so the \"d\" code performs no rounding.  128-bit floating point will\n  cause the \"d\" code to simply truncate significands to 52 bits.\n\nA format character may be preceded by an integral repeat count.  For example,\nthe format string \"4h\" means exactly the same thing as \"hhhh\".\n\nWhitespace characters between formats are ignored; a count and its format must\nnot be separated by whitespace, however.\n\nFor the \"A\" format character, the count is interpreted as the size of the\narray, not a repeat count as for the other format characters; for example, \"10A\"\nmeans a single 10-octet array.  When packing, the Array is truncated or padded\nwith 0 bytes as appropriate to make it conform to the specified length.  When\nunpacking, the resulting Array always has exactly the specified number of bytes.\nAs a special case, \"0A\" means a single, empty Array.\n\nFor the \"s\" format character, the count is interpreted as the size of the\nstring, not a repeat count as for the other format characters; for example,\n\"10s\" means a single 10-byte string, while \"10c\" means 10 characters.  When\npacking, the string is truncated or padded with 0 bytes as appropriate to make\nit conform to the specified length.  When unpacking, the resulting string always\nhas exactly the specified number of bytes.  As a special case, \"0s\" means a\nsingle, empty string (while \"0c\" means 0 characters).\n\n\nBy default, C numbers are represented in network (or big-endian) byte order.\nAlternatively, the first character of the format string can be used to indicate\nbyte order of the packed data, according to the following table:\n\n    Character | Byte Order\n    ----------------------------------\n        <     | little-endian\n        >     | big-endian\n        !     | network (= big-endian)\n\nIf the first character is not one of these, \"!\" is assumed.\n",
  "readmeFilename": "README",
  "_id": "jspack@0.0.1",
  "_from": "jspack@0.0.1"
}
